/**
 *                                 Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright 2018 Mike Hummel
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package de.mhus.lib.core.io;

import java.io.BufferedReader;
import java.io.EOFException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * Read CSV (Comma Separated Value) files. This format is used my Microsoft Word
 * and Excel. Fields are separated by commas, and enclosed in quotes if they
 * contain commas or quotes. Embedded quotes are doubled. Embedded spaces do not
 * normally require surrounding quotes. The last field on the line is not
 * followed by a comma. Null fields are represented by two commas in a row. We
 * optionally trim leading and trailing spaces on fields, even inside quotes.
 * File must normally end with a single CrLf, other wise you will get a null
 * when trying to read a field on older JVMs.
 * 
 * @author copyright (c) 2002-2006 Roedy Green Canadian Mind Products version
 *         1.0 2002 March 27 <br>
 *         1.1 2002 March 28 - close - configurable separator char - no longer
 *         sensitive to line-ending convention. - uses a categorise routine to
 *         massage categories for use in case clauses. - faster skipToNextLine <br>
 *         1.2 2002 April 23 - put in to separate package <br>
 *         1.4 2002 April 19 - fix bug if last field on line is empty, was not
 *         counting as a field.<br>
 *         1.6 2002 May 25 - allow choice of " or ' quote char. <br>
 *         1.7 2002 August 29 - getAllFieldsInLine<br>
 *         1.8 2002 November 12 - allow Microsoft Excel format fields that can
 *         span several lines. sponsored by Steve Hunter of agilense.com <br>
 *         1.9 2002 November 14 - trim parameter to control whether fields are
 *         trimmed of lead/trail whitespace (blanks, Cr, Lf, Tab etc.) <br>
 *         2.0 2003 August 10 - getInt, getLong, getFloat, getDouble <br>
 *         2.1 2005-07-16 - reorganisation, new bat files. <br>
 *         2.2 2005-08-28 - add CSVAlign and CSVPack to the suite.<br>
 * <BR>
 *         There is another CSVReader at: at
 *         http://ostermiller.org/utils/ExcelCSV.html If this CSVReader is not
 *         suitable for you, try that one. <br>
 *         There is one written in C# at http://www.csvreader.com/ <br>
 *         Future ideas: <br>
 *         1. allow specify various comment chars that mean the rest of the line
 *         should be ignored. e.g. ; ! #. These chars have to be in quotes in
 *         data then. <br>
 *         2. allow \ to be used for quoting characters.
 */

public class CSVReader {

	// ------------------------------ FIELDS ------------------------------

	public static final char NO_QUOTS = 0;
	
	/**
	 * parser: We have just hit a quote, might be doubled or might be last one.
	 */
	private static final int AFTER_END_QUOTE = 3;

	private static final boolean DEBUGGING = false;

	/**
	 * category of end of line char.
	 */
	private static final int EOL = 0;

	/**
	 * parser: We are in the middle of an ordinary field.
	 */
	private static final int IN_PLAIN = 1;

	/**
	 * parser: e are in middle of field surrounded in quotes.
	 */
	private static final int IN_QUOTED = 2;

	/**
	 * category of ordinary character
	 */
	private static final int ORDINARY = 1;

	/**
	 * categotory of the quote mark "
	 */
	private static final int QUOTE = 2;

	/**
	 * parser: We are in blanks before the field.
	 */
	private static final int SEEKING_START = 0;

	/**
	 * category of the separator, e.g. comma, semicolon or tab.
	 */
	private static final int SEPARATOR = 3;

	/**
	 * parser: We are in blanks after the field looking for the separator
	 */
	private static final int SKIPPING_TAIL = 4;

	/**
	 * category of characters treated as white space.
	 */
	private static final int WHITESPACE = 4;

	/**
	 * e.g. \n \r\n or \r, whatever system uses to separate lines in a text
	 * file. Only used inside multiline fields. The file itself should use
	 * Windows format \r \n, though \n by itself will also work.
	 */
	static String lineSeparator = System.getProperty("line.separator");

	/**
	 * Reader source of the CSV fields to be read.
	 */
	private BufferedReader r;

	/**
	 * state of the parser's finite state automaton. <p/> The line we are
	 * parsing. null means none read yet. Line contains unprocessed chars.
	 * Processed ones are removed. <p/> The line we are parsing. null means none
	 * read yet. Line contains unprocessed chars. Processed ones are removed.
	 * <p/> The line we are parsing. null means none read yet. Line contains
	 * unprocessed chars. Processed ones are removed.
	 */

	/**
	 * The line we are parsing. null means none read yet. Line contains
	 * unprocessed chars. Processed ones are removed.
	 */
	private String line = null;

	/**
	 * false means next EOL marks an empty field true means next EOL marks the
	 * end of all fields.
	 */
	private boolean allFieldsDone = true;

	/**
	 * true if reader should allow quoted fields to span more than one line.
	 * Microsoft Excel sometimes generates files like this.
	 */
	private final boolean allowMultiLineFields;

	/**
	 * true if reader should trim lead/trail whitespace from fields returned.
	 */
	private final boolean trim;

	/**
	 * quote character, usually '\"' '\'' for SOL used to enclose fields
	 * containing a separator character.
	 */
	private final char quote;

	/**
	 * field separator character, usually ',' in North America, ';' in Europe
	 * and sometimes '\t' for tab.
	 */
	private final char separator;

	/**
	 * How many lines we have read so far. Used in error messages.
	 */
	private int lineCount = 0;

	private HashMap<String, Integer> headerIndex;

	private String[] currentLine;

	// -------------------------- STATIC METHODS --------------------------

	static {
		if (lineSeparator == null) {
			lineSeparator = "\015012"; /* crlf in octal */
		}
	}

	// --------------------------- CONSTRUCTORS ---------------------------

	/**
	 * convenience Constructor, default to comma separator, " for quote, no
	 * multiline fields, with trimming.
	 * 
	 * @param r
	 *            input Reader source of CSV Fields to read.
	 */
	public CSVReader(Reader r) {
		this(r, ',', '\"', false, true);
	}

	/**
	 * Constructor
	 * 
	 * @param r
	 *            input Reader source of CSV Fields to read.
	 * @param separator
	 *            field separator character, usually ',' in North America, ';'
	 *            in Europe and sometimes '\t' for tab.
	 * @param quote
	 *            char to use to enclose fields containing a separator, usually
	 *            '\"'
	 * @param allowMultiLineFields
	 *            true if reader should allow quoted fields to span more than
	 *            one line. Microsoft Excel sometimes generates files like this.
	 * @param trim
	 *            true if reader should trim lead/trailing whitespace e.g.
	 *            blanks, Cr, Lf. Tab off fields.
	 */
	public CSVReader(Reader r, char separator, char quote,
			boolean allowMultiLineFields, boolean trim) {
		/* convert Reader to BufferedReader if necessary */
		if (r instanceof BufferedReader) {
			this.r = (BufferedReader) r;
		} else {
			this.r = new BufferedReader(r);
		}
		if (this.r == null) {
			throw new IllegalArgumentException("invalid Reader");
		}

		this.separator = separator;
		this.quote = quote;
		this.allowMultiLineFields = allowMultiLineFields;
		this.trim = trim;
	}

	// -------------------------- OTHER METHODS --------------------------

	/**
	 * categorise a character for the finite state machine.
	 * 
	 * @param c
	 *            the character to categorise
	 * 
	 * @return integer representing the character's category.
	 */
	private int categorise(char c) {
		switch (c) {
		case ' ':
		case '\r':
		case '\t':
		case 0xff:
			return WHITESPACE;

		case '\n':
			return EOL; /* artificially applied to end of line */

		default:
			if (c == quote) {
				return QUOTE;
			} else if (c == separator /*
									 * dynamically determined so can't use as
									 * case label
									 */) {
				return SEPARATOR;
			}
			/* do our tests in crafted order, hoping for an early return */
			else if ('!' <= c && c <= '~') {
				return ORDINARY;
			} else if (0x00 <= c && c <= 0x20) {
				return WHITESPACE;
			} else if (Character.isWhitespace(c)) {
				return WHITESPACE;
			} else {
				return ORDINARY;
			}
		}
	}

	/**
	 * Close the Reader.
	 * 
	 * @throws IOException
	 */
	public void close() throws IOException {
		if (r != null) {
			r.close();
			r = null;
		}
	}

	/**
	 * Read one field from the CSV file
	 * 
	 * @return String value, even if the field is numeric. Surrounded and
	 *         embedded double quotes are stripped. possibly "". null means end
	 *         of line.
	 * 
	 * @throws EOFException
	 *             at end of file after all the fields have been read.
	 * @throws IOException
	 *             Some problem reading the file, possibly malformed data.
	 */
	public String get() throws EOFException, IOException {
		StringBuffer field = new StringBuffer(allowMultiLineFields ? 512 : 64);
		/* we implement the parser as a finite state automaton with five states. */

		int state = SEEKING_START; /*
									 * start seeking, even if partway through a
									 * line
									 */
		/* don't need to maintain state between fields. */

		while (true) {
			getLineIfNeeded();

			charLoop:
			/* loop for each char in the line to find a field */
			/* guaranteed to leave early by hitting EOL */
			for (int i = 0; i < line.length(); i++) {
				char c = line.charAt(i);
				int category = categorise(c);
				switch (state) {
				case SEEKING_START: { /* in blanks before field */
					switch (category) {
					case WHITESPACE:
						/* ignore */
						break;

					case QUOTE:
						state = IN_QUOTED;
						break;

					case SEPARATOR:
						/* end of empty field */
						line = line.substring(i + 1);
						return "";

					case EOL:
						/* end of line */
						if (allFieldsDone) {
							/* null to mark end of line */
							line = null;
							return null;
						} else {
							/* empty field, usually after a comma */
							allFieldsDone = true;
							line = line.substring(i);
							return "";
						}

					case ORDINARY:
						field.append(c);
						state = IN_PLAIN;
						break;
					}
					break;
				}
				case IN_PLAIN: { /* in middle of ordinary field */
					switch (category) {
					case QUOTE:
						throw new IOException(
								"Malformed CSV stream. Missing quote at start of field on line "
										+ lineCount);

					case SEPARATOR:
						/* done */
						line = line.substring(i + 1);
						return maybeTrim(field.toString());

					case EOL:
						line = line.substring(i); /* push EOL back */
						allFieldsDone = true;
						return maybeTrim(field.toString());

					case WHITESPACE:
						field.append(' ');
						break;

					case ORDINARY:
						field.append(c);
						break;
					}
					break;
				}

				case IN_QUOTED: { /* in middle of field surrounded in quotes */
					switch (category) {
					case QUOTE:
						state = AFTER_END_QUOTE;
						break;

					case EOL:
						if (allowMultiLineFields) {
							field.append(lineSeparator);
							// we are done with that line, but not with
							// the
							// field.
							// We don't want to return a null
							// to mark the end of the line.
							line = null;
							// will read next line and seek the end of
							// the
							// quoted field.
							// with state = IN_QUOTED.
							break charLoop;
						} else {
							// no multiline fields allowed
							allFieldsDone = true;
							throw new IOException(
									"Malformed CSV stream. Missing quote (\") after field on line "
											+ lineCount);
						}
					case WHITESPACE:
						field.append(' ');
						break;

					case SEPARATOR:
					case ORDINARY:
						field.append(c);
						break;
					}
					break;
				}

				case AFTER_END_QUOTE: {
					/*
					 * In situation like this "xxx" which may turn out to be
					 * xxx""xxx" or "xxx", We find out here.
					 */
					switch (category) {
					case QUOTE:
						/* was a double quote, e.g. a literal " */
						field.append(c);
						state = IN_QUOTED;
						break;

					case SEPARATOR:
						/* we are done with field. */
						line = line.substring(i + 1);
						return maybeTrim(field.toString());

					case EOL:
						line = line.substring(i); /* push back eol */
						allFieldsDone = true;
						return maybeTrim(field.toString());

					case WHITESPACE:
						/* ignore trailing spaces up to separator */
						state = SKIPPING_TAIL;
						break;

					case ORDINARY:
						throw new IOException(
								"Malformed CSV stream, missing separator after fieldon line "
										+ lineCount);
					}
					break;
				}

				case SKIPPING_TAIL: {
					/* in spaces after field seeking separator */

					switch (category) {
					case SEPARATOR:
						/* we are done. */
						line = line.substring(i + 1);
						return maybeTrim(field.toString());

					case EOL:
						line = line.substring(i); /* push back eol */
						allFieldsDone = true;
						return maybeTrim(field.toString());

					case WHITESPACE:
						/* ignore trailing spaces up to separator */
						break;

					case QUOTE:
					case ORDINARY:
						throw new IOException(
								"Malformed CSV stream, missing separator after field on line "
										+ lineCount);
					}
					break;
				}
				} // end switch(state)
			} // end charLoop
		} // end lineLoop
	} // end get

	/**
	 * Get all fields in the line
	 * 
	 * @return Array of strings, one for each field. Possibly empty, but never
	 *         null.
	 * 
	 * @throws EOFException
	 * @throws IOException
	 */
	public String[] getAllFieldsInLine() throws EOFException, IOException {
		ArrayList<String> al = new ArrayList<String>(30);
		do {
			String field = get();
			if (field == null) {
				break;
			}
			al.add(field);
		} while (true);
		return (String[]) (al.toArray(new String[al.size()]));
	}

	/**
	 * Read one double field from the CSV file.
	 * 
	 * @return houble value, empty field returns 0, as does end of line.
	 * 
	 * @throws EOFException
	 *             at end of file after all the fields have been read.
	 * @throws IOException
	 *             Some problem reading the file, possibly malformed data.
	 * @throws NumberFormatException
	 *             , if field does not contain a well-formed int.
	 */
	public double getDouble() throws EOFException, IOException,
			NumberFormatException {
		String s = get();
		if (s == null) {
			return 0;
		}
		if (!trim) {
			s = s.trim();
		}
		if (s.length() == 0) {
			return 0;
		}
		return Double.parseDouble(s);
	}

	/**
	 * Read one float field from the CSV file.
	 * 
	 * @return float value, empty field returns 0, as does end of line.
	 * 
	 * @throws EOFException
	 *             at end of file after all the fields have been read.
	 * @throws IOException
	 *             Some problem reading the file, possibly malformed data.
	 * @throws NumberFormatException
	 *             , if field does not contain a well-formed int.
	 */
	public float getFloat() throws EOFException, IOException,
			NumberFormatException {
		String s = get();
		if (s == null) {
			return 0;
		}
		if (!trim) {
			s = s.trim();
		}
		if (s.length() == 0) {
			return 0;
		}
		return Float.parseFloat(s);
	}

	/**
	 * Read one integer field from the CSV file
	 * 
	 * @return int value, empty field returns 0, as does end of line.
	 * 
	 * @throws EOFException
	 *             at end of file after all the fields have been read.
	 * @throws IOException
	 *             Some problem reading the file, possibly malformed data.
	 * @throws NumberFormatException
	 *             , if field does not contain a well-formed int.
	 */
	public int getInt() throws EOFException, IOException, NumberFormatException {
		String s = get();
		// end of line returns 0
		if (s == null) {
			return 0;
		}
		if (!trim) {
			s = s.trim();
		}
		if (s.length() == 0) {
			return 0;
		}
		return Integer.parseInt(s);
	}

	/**
	 * Make sure a line is available for parsing. Does nothing if there already
	 * is one.
	 * 
	 * @throws EOFException
	 */
	private void getLineIfNeeded() throws EOFException, IOException {
		if (line == null) {
			if (r == null) {
				throw new IllegalArgumentException(
						"attempt to use a closed CSVReader");
			}
			allFieldsDone = false;
			line = r.readLine(); /* this strips platform specific line ending */
			if (line == null) /*
							 * null means EOF, yet another inconsistent Java
							 * convention.
							 */
			{
				throw new EOFException();
			} else {
				line += '\n'; /* apply standard line end for parser to find */
				lineCount++;
			}
		}
	}

	/**
	 * Read one long field from the CSV file
	 * 
	 * @return long value, empty field returns 0, as does end of line.
	 * 
	 * @throws EOFException
	 *             at end of file after all the fields have been read.
	 * @throws IOException
	 *             Some problem reading the file, possibly malformed data.
	 * @throws NumberFormatException
	 *             , if field does not contain a well-formed int.
	 */
	public long getLong() throws EOFException, IOException,
			NumberFormatException {
		String s = get();
		if (s == null) {
			return 0;
		}
		if (!trim) {
			s = s.trim();
		}

		if (s.length() == 0) {
			return 0;
		}
		return Long.parseLong(s);
	}

	/**
	 * Trim the string, but only if we are in trimming mode.
	 * 
	 * @param s
	 *            String to be trimmed.
	 * 
	 * @return String or trimmed string.
	 */
	private String maybeTrim(String s) {
		if (trim) {
			return s.trim();
		} else {
			return s;
		}
	}

	/**
	 * Skip over fields you don't want to process.
	 * 
	 * @param fields
	 *            How many field you want to bypass reading. The newline counts
	 *            as one field.
	 * 
	 * @throws EOFException
	 *             at end of file after all the fields have been read.
	 * @throws IOException
	 *             Some problem reading the file, possibly malformed data.
	 */
	public void skip(int fields) throws EOFException, IOException {
		if (fields <= 0) {
			return;
		}
		for (int i = 0; i < fields; i++) {
			// throw results away
			get();
		}
	}

	/**
	 * Skip over remaining fields on this line you don't want to process.
	 * 
	 * @throws EOFException
	 *             at end of file after all the fields have been read.
	 * @throws IOException
	 *             Some problem reading the file, possibly malformed data.
	 */
	public void skipToNextLine() throws EOFException, IOException {
		if (line == null) {
			getLineIfNeeded();
		}
		line = null;
	}

	public void readHeader(boolean lower) throws EOFException, IOException {
		currentLine = getAllFieldsInLine();
		headerIndex = new HashMap<>();
		for (int i = 0; i < currentLine.length; i++)
			headerIndex.put(lower ? currentLine[i].toLowerCase() : currentLine[i], i);
	}
	
	public String[] getRowNames() {
		return headerIndex.keySet().toArray(new String[headerIndex.size()]);
	}
	
	public boolean next() throws IOException {
		try {
			currentLine = getAllFieldsInLine();
		} catch (EOFException e) {
			return false;
		}
		return true;
	}
	
	public String get(String row) throws IOException {
		Integer idx = headerIndex.get(row);
		if (idx == null) throw new IOException("row not found " + row);
		return currentLine[ idx ];
	}
	
	public String get(int row) {
		return currentLine[row];
	}
	
	public int getLineCount() {
		return lineCount;
	}
	
	public int getLineColumns() {
		return currentLine.length;
	}
	
	public String[] getCurrentLine() {
		return currentLine;
	}
	
	// --------------------------- main() method ---------------------------

	/**
	 * Test driver
	 * 
	 * @param args
	 *            not used
	 */
	public static void main(String[] args) {
		if (DEBUGGING) {
			try {
				// read test file
				@SuppressWarnings("resource")
				CSVReader csv = new CSVReader(new FileReader("test.csv"), ',',
						'\"', true, false);
				try {
					while (true) {
						System.out.println("--> " + csv.get());
					}
				} catch (EOFException e) {
				}
				csv.close();
			} catch (IOException e) {
				e.printStackTrace();
				System.out.println(e.getMessage());
			}
		} // end if
	} // end main
} // end CSVReader class.
